/*
 * generated by Xtext 2.10.0
 */
package org.xtext.example.mydsl.serializer;

import com.google.inject.Inject;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.ocl.xtext.basecs.BaseCSPackage;
import org.eclipse.ocl.xtext.basecs.ConstraintCS;
import org.eclipse.ocl.xtext.basecs.ImportCS;
import org.eclipse.ocl.xtext.basecs.MultiplicityBoundsCS;
import org.eclipse.ocl.xtext.basecs.MultiplicityStringCS;
import org.eclipse.ocl.xtext.basecs.ParameterCS;
import org.eclipse.ocl.xtext.basecs.PathElementCS;
import org.eclipse.ocl.xtext.basecs.PathElementWithURICS;
import org.eclipse.ocl.xtext.basecs.PathNameCS;
import org.eclipse.ocl.xtext.basecs.PrimitiveTypeRefCS;
import org.eclipse.ocl.xtext.basecs.TemplateBindingCS;
import org.eclipse.ocl.xtext.basecs.TemplateParameterSubstitutionCS;
import org.eclipse.ocl.xtext.basecs.TemplateSignatureCS;
import org.eclipse.ocl.xtext.basecs.TuplePartCS;
import org.eclipse.ocl.xtext.basecs.TupleTypeCS;
import org.eclipse.ocl.xtext.basecs.TypeParameterCS;
import org.eclipse.ocl.xtext.basecs.TypedTypeRefCS;
import org.eclipse.ocl.xtext.basecs.WildcardTypeRefCS;
import org.eclipse.ocl.xtext.completeocl.serializer.CompleteOCLSemanticSequencer;
import org.eclipse.ocl.xtext.completeoclcs.ClassifierContextDeclCS;
import org.eclipse.ocl.xtext.completeoclcs.CompleteOCLCSPackage;
import org.eclipse.ocl.xtext.completeoclcs.CompleteOCLDocumentCS;
import org.eclipse.ocl.xtext.completeoclcs.DefOperationCS;
import org.eclipse.ocl.xtext.completeoclcs.DefPropertyCS;
import org.eclipse.ocl.xtext.completeoclcs.OCLMessageArgCS;
import org.eclipse.ocl.xtext.completeoclcs.OperationContextDeclCS;
import org.eclipse.ocl.xtext.completeoclcs.PackageDeclarationCS;
import org.eclipse.ocl.xtext.completeoclcs.PropertyContextDeclCS;
import org.eclipse.ocl.xtext.essentialoclcs.BooleanLiteralExpCS;
import org.eclipse.ocl.xtext.essentialoclcs.CollectionLiteralExpCS;
import org.eclipse.ocl.xtext.essentialoclcs.CollectionLiteralPartCS;
import org.eclipse.ocl.xtext.essentialoclcs.CollectionPatternCS;
import org.eclipse.ocl.xtext.essentialoclcs.CollectionTypeCS;
import org.eclipse.ocl.xtext.essentialoclcs.ContextCS;
import org.eclipse.ocl.xtext.essentialoclcs.CurlyBracketedClauseCS;
import org.eclipse.ocl.xtext.essentialoclcs.EssentialOCLCSPackage;
import org.eclipse.ocl.xtext.essentialoclcs.ExpSpecificationCS;
import org.eclipse.ocl.xtext.essentialoclcs.IfExpCS;
import org.eclipse.ocl.xtext.essentialoclcs.IfThenExpCS;
import org.eclipse.ocl.xtext.essentialoclcs.InfixExpCS;
import org.eclipse.ocl.xtext.essentialoclcs.InvalidLiteralExpCS;
import org.eclipse.ocl.xtext.essentialoclcs.LambdaLiteralExpCS;
import org.eclipse.ocl.xtext.essentialoclcs.LetExpCS;
import org.eclipse.ocl.xtext.essentialoclcs.LetVariableCS;
import org.eclipse.ocl.xtext.essentialoclcs.MapLiteralExpCS;
import org.eclipse.ocl.xtext.essentialoclcs.MapLiteralPartCS;
import org.eclipse.ocl.xtext.essentialoclcs.MapTypeCS;
import org.eclipse.ocl.xtext.essentialoclcs.NameExpCS;
import org.eclipse.ocl.xtext.essentialoclcs.NavigatingArgCS;
import org.eclipse.ocl.xtext.essentialoclcs.NestedExpCS;
import org.eclipse.ocl.xtext.essentialoclcs.NullLiteralExpCS;
import org.eclipse.ocl.xtext.essentialoclcs.NumberLiteralExpCS;
import org.eclipse.ocl.xtext.essentialoclcs.PatternExpCS;
import org.eclipse.ocl.xtext.essentialoclcs.PrefixExpCS;
import org.eclipse.ocl.xtext.essentialoclcs.RoundBracketedClauseCS;
import org.eclipse.ocl.xtext.essentialoclcs.SelfExpCS;
import org.eclipse.ocl.xtext.essentialoclcs.ShadowPartCS;
import org.eclipse.ocl.xtext.essentialoclcs.SquareBracketedClauseCS;
import org.eclipse.ocl.xtext.essentialoclcs.StringLiteralExpCS;
import org.eclipse.ocl.xtext.essentialoclcs.TupleLiteralExpCS;
import org.eclipse.ocl.xtext.essentialoclcs.TupleLiteralPartCS;
import org.eclipse.ocl.xtext.essentialoclcs.TypeLiteralExpCS;
import org.eclipse.ocl.xtext.essentialoclcs.TypeNameExpCS;
import org.eclipse.ocl.xtext.essentialoclcs.UnlimitedNaturalLiteralExpCS;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;
import org.xtext.example.mydsl.myDsl.AbortProperty;
import org.xtext.example.mydsl.myDsl.AlwaysProperty;
import org.xtext.example.mydsl.myDsl.AndProperty;
import org.xtext.example.mydsl.myDsl.BeforeProperty;
import org.xtext.example.mydsl.myDsl.BooleanConsecutiveRepetition;
import org.xtext.example.mydsl.myDsl.BooleanCountedConsecutiveRepetition;
import org.xtext.example.mydsl.myDsl.BooleanCountedGotoRepetition;
import org.xtext.example.mydsl.myDsl.BooleanCountedNonConsecutiveRepetition;
import org.xtext.example.mydsl.myDsl.BooleanLiteral;
import org.xtext.example.mydsl.myDsl.BooleanProperty;
import org.xtext.example.mydsl.myDsl.BracedSERE;
import org.xtext.example.mydsl.myDsl.ConcatenationSERE;
import org.xtext.example.mydsl.myDsl.Count;
import org.xtext.example.mydsl.myDsl.Document;
import org.xtext.example.mydsl.myDsl.EquivalenceProperty;
import org.xtext.example.mydsl.myDsl.EventuallyBooleanProperty;
import org.xtext.example.mydsl.myDsl.EventuallySequenceProperty;
import org.xtext.example.mydsl.myDsl.FusionSERE;
import org.xtext.example.mydsl.myDsl.ImpliesProperty;
import org.xtext.example.mydsl.myDsl.Import;
import org.xtext.example.mydsl.myDsl.LengthOne;
import org.xtext.example.mydsl.myDsl.MyDslPackage;
import org.xtext.example.mydsl.myDsl.NeverBooleanProperty;
import org.xtext.example.mydsl.myDsl.NeverSequenceProperty;
import org.xtext.example.mydsl.myDsl.NextEProperty;
import org.xtext.example.mydsl.myDsl.NextEventAProperty;
import org.xtext.example.mydsl.myDsl.NotBooleanOrOCLLiteral;
import org.xtext.example.mydsl.myDsl.OCLLiteral;
import org.xtext.example.mydsl.myDsl.OrBooleanPropertyProperty;
import org.xtext.example.mydsl.myDsl.OrPropertyBooleanProperty;
import org.xtext.example.mydsl.myDsl.OverlappingSuffixImplicationProperty;
import org.xtext.example.mydsl.myDsl.OverlappingUntilProperty;
import org.xtext.example.mydsl.myDsl.Range;
import org.xtext.example.mydsl.myDsl.SEREAndLM;
import org.xtext.example.mydsl.myDsl.SEREAndNLM;
import org.xtext.example.mydsl.myDsl.SEREOr;
import org.xtext.example.mydsl.myDsl.SEREWithin;
import org.xtext.example.mydsl.myDsl.SequenceConsecutiveRepetition;
import org.xtext.example.mydsl.myDsl.SequenceCountedConsecutiveRepetition;
import org.xtext.example.mydsl.myDsl.SequenceProperty;
import org.xtext.example.mydsl.myDsl.SequenceTightProperty;
import org.xtext.example.mydsl.myDsl.SuffixImplicationProperty;
import org.xtext.example.mydsl.myDsl.UntilProperty;
import org.xtext.example.mydsl.myDsl.WildCard;
import org.xtext.example.mydsl.services.MyDslGrammarAccess;

@SuppressWarnings("all")
public class MyDslSemanticSequencer extends CompleteOCLSemanticSequencer {

	@Inject
	private MyDslGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == BaseCSPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case BaseCSPackage.CONSTRAINT_CS:
				sequence_ConstraintCS(context, (ConstraintCS) semanticObject); 
				return; 
			case BaseCSPackage.IMPORT_CS:
				sequence_ImportCS(context, (ImportCS) semanticObject); 
				return; 
			case BaseCSPackage.MULTIPLICITY_BOUNDS_CS:
				if (rule == grammarAccess.getMultiplicityBoundsCSRule()) {
					sequence_MultiplicityBoundsCS(context, (MultiplicityBoundsCS) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getMultiplicityCSRule()) {
					sequence_MultiplicityBoundsCS_MultiplicityCS(context, (MultiplicityBoundsCS) semanticObject); 
					return; 
				}
				else break;
			case BaseCSPackage.MULTIPLICITY_STRING_CS:
				if (rule == grammarAccess.getMultiplicityCSRule()) {
					sequence_MultiplicityCS_MultiplicityStringCS(context, (MultiplicityStringCS) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getMultiplicityStringCSRule()) {
					sequence_MultiplicityStringCS(context, (MultiplicityStringCS) semanticObject); 
					return; 
				}
				else break;
			case BaseCSPackage.PARAMETER_CS:
				if (rule == grammarAccess.getDefParameterCSRule()) {
					sequence_DefParameterCS(context, (ParameterCS) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getParameterCSRule()) {
					sequence_ParameterCS(context, (ParameterCS) semanticObject); 
					return; 
				}
				else break;
			case BaseCSPackage.PATH_ELEMENT_CS:
				if (rule == grammarAccess.getFirstPathElementCSRule()) {
					sequence_FirstPathElementCS(context, (PathElementCS) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getNextPathElementCSRule()) {
					sequence_NextPathElementCS(context, (PathElementCS) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getURIFirstPathElementCSRule()) {
					sequence_URIFirstPathElementCS(context, (PathElementCS) semanticObject); 
					return; 
				}
				else break;
			case BaseCSPackage.PATH_ELEMENT_WITH_URICS:
				sequence_URIFirstPathElementCS(context, (PathElementWithURICS) semanticObject); 
				return; 
			case BaseCSPackage.PATH_NAME_CS:
				if (rule == grammarAccess.getPathNameCSRule()) {
					sequence_PathNameCS(context, (PathNameCS) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getURIPathNameCSRule()) {
					sequence_URIPathNameCS(context, (PathNameCS) semanticObject); 
					return; 
				}
				else break;
			case BaseCSPackage.PRIMITIVE_TYPE_REF_CS:
				if (rule == grammarAccess.getTypedRefCSRule()
						|| rule == grammarAccess.getPrimitiveTypeCSRule()
						|| rule == grammarAccess.getTypeLiteralCSRule()
						|| rule == grammarAccess.getTypeRefCSRule()) {
					sequence_PrimitiveTypeCS(context, (PrimitiveTypeRefCS) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getTypeExpCSRule()) {
					sequence_PrimitiveTypeCS_TypeExpCS(context, (PrimitiveTypeRefCS) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getTypeLiteralWithMultiplicityCSRule()) {
					sequence_PrimitiveTypeCS_TypeLiteralWithMultiplicityCS(context, (PrimitiveTypeRefCS) semanticObject); 
					return; 
				}
				else break;
			case BaseCSPackage.TEMPLATE_BINDING_CS:
				sequence_TemplateBindingCS(context, (TemplateBindingCS) semanticObject); 
				return; 
			case BaseCSPackage.TEMPLATE_PARAMETER_SUBSTITUTION_CS:
				sequence_TemplateParameterSubstitutionCS(context, (TemplateParameterSubstitutionCS) semanticObject); 
				return; 
			case BaseCSPackage.TEMPLATE_SIGNATURE_CS:
				sequence_TemplateSignatureCS(context, (TemplateSignatureCS) semanticObject); 
				return; 
			case BaseCSPackage.TUPLE_PART_CS:
				sequence_TuplePartCS(context, (TuplePartCS) semanticObject); 
				return; 
			case BaseCSPackage.TUPLE_TYPE_CS:
				if (rule == grammarAccess.getTypedRefCSRule()
						|| rule == grammarAccess.getTupleTypeCSRule()
						|| rule == grammarAccess.getTypeLiteralCSRule()
						|| rule == grammarAccess.getTypeRefCSRule()) {
					sequence_TupleTypeCS(context, (TupleTypeCS) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getTypeExpCSRule()) {
					sequence_TupleTypeCS_TypeExpCS(context, (TupleTypeCS) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getTypeLiteralWithMultiplicityCSRule()) {
					sequence_TupleTypeCS_TypeLiteralWithMultiplicityCS(context, (TupleTypeCS) semanticObject); 
					return; 
				}
				else break;
			case BaseCSPackage.TYPE_PARAMETER_CS:
				sequence_TypeParameterCS(context, (TypeParameterCS) semanticObject); 
				return; 
			case BaseCSPackage.TYPED_TYPE_REF_CS:
				sequence_TypedTypeRefCS(context, (TypedTypeRefCS) semanticObject); 
				return; 
			case BaseCSPackage.WILDCARD_TYPE_REF_CS:
				sequence_WildcardTypeRefCS(context, (WildcardTypeRefCS) semanticObject); 
				return; 
			}
		else if (epackage == CompleteOCLCSPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case CompleteOCLCSPackage.CLASSIFIER_CONTEXT_DECL_CS:
				sequence_ClassifierContextDeclCS(context, (ClassifierContextDeclCS) semanticObject); 
				return; 
			case CompleteOCLCSPackage.COMPLETE_OCL_DOCUMENT_CS:
				sequence_CompleteOCLDocumentCS(context, (CompleteOCLDocumentCS) semanticObject); 
				return; 
			case CompleteOCLCSPackage.DEF_OPERATION_CS:
				sequence_DefOperationCS(context, (DefOperationCS) semanticObject); 
				return; 
			case CompleteOCLCSPackage.DEF_PROPERTY_CS:
				sequence_DefPropertyCS(context, (DefPropertyCS) semanticObject); 
				return; 
			case CompleteOCLCSPackage.OCL_MESSAGE_ARG_CS:
				sequence_NavigatingArgExpCS(context, (OCLMessageArgCS) semanticObject); 
				return; 
			case CompleteOCLCSPackage.OPERATION_CONTEXT_DECL_CS:
				sequence_OperationContextDeclCS(context, (OperationContextDeclCS) semanticObject); 
				return; 
			case CompleteOCLCSPackage.PACKAGE_DECLARATION_CS:
				sequence_PackageDeclarationCS(context, (PackageDeclarationCS) semanticObject); 
				return; 
			case CompleteOCLCSPackage.PROPERTY_CONTEXT_DECL_CS:
				sequence_PropertyContextDeclCS(context, (PropertyContextDeclCS) semanticObject); 
				return; 
			}
		else if (epackage == EssentialOCLCSPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case EssentialOCLCSPackage.BOOLEAN_LITERAL_EXP_CS:
				sequence_BooleanLiteralExpCS(context, (BooleanLiteralExpCS) semanticObject); 
				return; 
			case EssentialOCLCSPackage.COLLECTION_LITERAL_EXP_CS:
				sequence_CollectionLiteralExpCS(context, (CollectionLiteralExpCS) semanticObject); 
				return; 
			case EssentialOCLCSPackage.COLLECTION_LITERAL_PART_CS:
				sequence_CollectionLiteralPartCS(context, (CollectionLiteralPartCS) semanticObject); 
				return; 
			case EssentialOCLCSPackage.COLLECTION_PATTERN_CS:
				if (rule == grammarAccess.getCollectionPatternCSRule()) {
					sequence_CollectionPatternCS(context, (CollectionPatternCS) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getTypeExpCSRule()) {
					sequence_CollectionPatternCS_TypeExpCS(context, (CollectionPatternCS) semanticObject); 
					return; 
				}
				else break;
			case EssentialOCLCSPackage.COLLECTION_TYPE_CS:
				if (rule == grammarAccess.getTypedRefCSRule()
						|| rule == grammarAccess.getCollectionTypeCSRule()
						|| rule == grammarAccess.getTypeLiteralCSRule()
						|| rule == grammarAccess.getTypeRefCSRule()) {
					sequence_CollectionTypeCS(context, (CollectionTypeCS) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getTypeExpCSRule()) {
					sequence_CollectionTypeCS_TypeExpCS(context, (CollectionTypeCS) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getTypeLiteralWithMultiplicityCSRule()) {
					sequence_CollectionTypeCS_TypeLiteralWithMultiplicityCS(context, (CollectionTypeCS) semanticObject); 
					return; 
				}
				else break;
			case EssentialOCLCSPackage.CONTEXT_CS:
				sequence_Model(context, (ContextCS) semanticObject); 
				return; 
			case EssentialOCLCSPackage.CURLY_BRACKETED_CLAUSE_CS:
				sequence_CurlyBracketedClauseCS(context, (CurlyBracketedClauseCS) semanticObject); 
				return; 
			case EssentialOCLCSPackage.EXP_SPECIFICATION_CS:
				sequence_SpecificationCS(context, (ExpSpecificationCS) semanticObject); 
				return; 
			case EssentialOCLCSPackage.IF_EXP_CS:
				sequence_IfExpCS(context, (IfExpCS) semanticObject); 
				return; 
			case EssentialOCLCSPackage.IF_THEN_EXP_CS:
				sequence_ElseIfThenExpCS(context, (IfThenExpCS) semanticObject); 
				return; 
			case EssentialOCLCSPackage.INFIX_EXP_CS:
				sequence_ExpCS(context, (InfixExpCS) semanticObject); 
				return; 
			case EssentialOCLCSPackage.INVALID_LITERAL_EXP_CS:
				sequence_InvalidLiteralExpCS(context, (InvalidLiteralExpCS) semanticObject); 
				return; 
			case EssentialOCLCSPackage.LAMBDA_LITERAL_EXP_CS:
				sequence_LambdaLiteralExpCS(context, (LambdaLiteralExpCS) semanticObject); 
				return; 
			case EssentialOCLCSPackage.LET_EXP_CS:
				sequence_LetExpCS(context, (LetExpCS) semanticObject); 
				return; 
			case EssentialOCLCSPackage.LET_VARIABLE_CS:
				sequence_LetVariableCS(context, (LetVariableCS) semanticObject); 
				return; 
			case EssentialOCLCSPackage.MAP_LITERAL_EXP_CS:
				sequence_MapLiteralExpCS(context, (MapLiteralExpCS) semanticObject); 
				return; 
			case EssentialOCLCSPackage.MAP_LITERAL_PART_CS:
				sequence_MapLiteralPartCS(context, (MapLiteralPartCS) semanticObject); 
				return; 
			case EssentialOCLCSPackage.MAP_TYPE_CS:
				if (rule == grammarAccess.getTypedRefCSRule()
						|| rule == grammarAccess.getMapTypeCSRule()
						|| rule == grammarAccess.getTypeLiteralCSRule()
						|| rule == grammarAccess.getTypeRefCSRule()) {
					sequence_MapTypeCS(context, (MapTypeCS) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getTypeExpCSRule()) {
					sequence_MapTypeCS_TypeExpCS(context, (MapTypeCS) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getTypeLiteralWithMultiplicityCSRule()) {
					sequence_MapTypeCS_TypeLiteralWithMultiplicityCS(context, (MapTypeCS) semanticObject); 
					return; 
				}
				else break;
			case EssentialOCLCSPackage.NAME_EXP_CS:
				sequence_NameExpCS(context, (NameExpCS) semanticObject); 
				return; 
			case EssentialOCLCSPackage.NAVIGATING_ARG_CS:
				if (rule == grammarAccess.getNavigatingArgCSRule()) {
					sequence_NavigatingArgCS(context, (NavigatingArgCS) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getNavigatingBarArgCSRule()) {
					sequence_NavigatingBarArgCS(context, (NavigatingArgCS) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getNavigatingCommaArgCSRule()) {
					sequence_NavigatingCommaArgCS(context, (NavigatingArgCS) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getNavigatingSemiArgCSRule()) {
					sequence_NavigatingSemiArgCS(context, (NavigatingArgCS) semanticObject); 
					return; 
				}
				else break;
			case EssentialOCLCSPackage.NESTED_EXP_CS:
				sequence_NestedExpCS(context, (NestedExpCS) semanticObject); 
				return; 
			case EssentialOCLCSPackage.NULL_LITERAL_EXP_CS:
				sequence_NullLiteralExpCS(context, (NullLiteralExpCS) semanticObject); 
				return; 
			case EssentialOCLCSPackage.NUMBER_LITERAL_EXP_CS:
				sequence_NumberLiteralExpCS(context, (NumberLiteralExpCS) semanticObject); 
				return; 
			case EssentialOCLCSPackage.PATTERN_EXP_CS:
				sequence_PatternExpCS(context, (PatternExpCS) semanticObject); 
				return; 
			case EssentialOCLCSPackage.PREFIX_EXP_CS:
				if (rule == grammarAccess.getPrefixedLetExpCSRule()) {
					sequence_PrefixedLetExpCS(context, (PrefixExpCS) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getNavigatingArgExpCSRule()
						|| rule == grammarAccess.getExpCSRule()) {
					sequence_PrefixedLetExpCS_PrefixedPrimaryExpCS(context, (PrefixExpCS) semanticObject); 
					return; 
				}
				else if (action == grammarAccess.getExpCSAccess().getInfixExpCSOwnedLeftAction_0_1_0()
						|| rule == grammarAccess.getPrefixedPrimaryExpCSRule()) {
					sequence_PrefixedPrimaryExpCS(context, (PrefixExpCS) semanticObject); 
					return; 
				}
				else break;
			case EssentialOCLCSPackage.ROUND_BRACKETED_CLAUSE_CS:
				sequence_RoundBracketedClauseCS(context, (RoundBracketedClauseCS) semanticObject); 
				return; 
			case EssentialOCLCSPackage.SELF_EXP_CS:
				sequence_SelfExpCS(context, (SelfExpCS) semanticObject); 
				return; 
			case EssentialOCLCSPackage.SHADOW_PART_CS:
				sequence_ShadowPartCS(context, (ShadowPartCS) semanticObject); 
				return; 
			case EssentialOCLCSPackage.SQUARE_BRACKETED_CLAUSE_CS:
				sequence_SquareBracketedClauseCS(context, (SquareBracketedClauseCS) semanticObject); 
				return; 
			case EssentialOCLCSPackage.STRING_LITERAL_EXP_CS:
				sequence_StringLiteralExpCS(context, (StringLiteralExpCS) semanticObject); 
				return; 
			case EssentialOCLCSPackage.TUPLE_LITERAL_EXP_CS:
				sequence_TupleLiteralExpCS(context, (TupleLiteralExpCS) semanticObject); 
				return; 
			case EssentialOCLCSPackage.TUPLE_LITERAL_PART_CS:
				sequence_TupleLiteralPartCS(context, (TupleLiteralPartCS) semanticObject); 
				return; 
			case EssentialOCLCSPackage.TYPE_LITERAL_EXP_CS:
				sequence_TypeLiteralExpCS(context, (TypeLiteralExpCS) semanticObject); 
				return; 
			case EssentialOCLCSPackage.TYPE_NAME_EXP_CS:
				if (rule == grammarAccess.getTypeExpCSRule()) {
					sequence_TypeExpCS_TypeNameExpCS(context, (TypeNameExpCS) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getTypeNameExpCSRule()) {
					sequence_TypeNameExpCS(context, (TypeNameExpCS) semanticObject); 
					return; 
				}
				else break;
			case EssentialOCLCSPackage.UNLIMITED_NATURAL_LITERAL_EXP_CS:
				sequence_UnlimitedNaturalLiteralExpCS(context, (UnlimitedNaturalLiteralExpCS) semanticObject); 
				return; 
			}
		else if (epackage == MyDslPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case MyDslPackage.ABORT_PROPERTY:
				sequence_Property(context, (AbortProperty) semanticObject); 
				return; 
			case MyDslPackage.ALWAYS_PROPERTY:
				sequence_UnaryProperty(context, (AlwaysProperty) semanticObject); 
				return; 
			case MyDslPackage.AND_PROPERTY:
				sequence_Property(context, (AndProperty) semanticObject); 
				return; 
			case MyDslPackage.BEFORE_PROPERTY:
				sequence_BinaryProperty(context, (BeforeProperty) semanticObject); 
				return; 
			case MyDslPackage.BOOLEAN_CONSECUTIVE_REPETITION:
				sequence_RepeatedSERE(context, (BooleanConsecutiveRepetition) semanticObject); 
				return; 
			case MyDslPackage.BOOLEAN_COUNTED_CONSECUTIVE_REPETITION:
				sequence_RepeatedSERE(context, (BooleanCountedConsecutiveRepetition) semanticObject); 
				return; 
			case MyDslPackage.BOOLEAN_COUNTED_GOTO_REPETITION:
				sequence_RepeatedSERE(context, (BooleanCountedGotoRepetition) semanticObject); 
				return; 
			case MyDslPackage.BOOLEAN_COUNTED_NON_CONSECUTIVE_REPETITION:
				sequence_RepeatedSERE(context, (BooleanCountedNonConsecutiveRepetition) semanticObject); 
				return; 
			case MyDslPackage.BOOLEAN_LITERAL:
				sequence_BooleanOrOCLLiteral(context, (BooleanLiteral) semanticObject); 
				return; 
			case MyDslPackage.BOOLEAN_PROPERTY:
				sequence_UnaryProperty(context, (BooleanProperty) semanticObject); 
				return; 
			case MyDslPackage.BRACED_SERE:
				sequence_BracedSERE(context, (BracedSERE) semanticObject); 
				return; 
			case MyDslPackage.CONCATENATION_SERE:
				sequence_SERE(context, (ConcatenationSERE) semanticObject); 
				return; 
			case MyDslPackage.COUNT:
				sequence_Count(context, (Count) semanticObject); 
				return; 
			case MyDslPackage.DOCUMENT:
				sequence_Document(context, (Document) semanticObject); 
				return; 
			case MyDslPackage.EQUIVALENCE_PROPERTY:
				sequence_BinaryProperty(context, (EquivalenceProperty) semanticObject); 
				return; 
			case MyDslPackage.EVENTUALLY_BOOLEAN_PROPERTY:
				sequence_UnaryProperty(context, (EventuallyBooleanProperty) semanticObject); 
				return; 
			case MyDslPackage.EVENTUALLY_SEQUENCE_PROPERTY:
				sequence_UnaryProperty(context, (EventuallySequenceProperty) semanticObject); 
				return; 
			case MyDslPackage.FUSION_SERE:
				sequence_SERE(context, (FusionSERE) semanticObject); 
				return; 
			case MyDslPackage.IMPLIES_PROPERTY:
				sequence_BinaryProperty(context, (ImpliesProperty) semanticObject); 
				return; 
			case MyDslPackage.IMPORT:
				sequence_Import(context, (Import) semanticObject); 
				return; 
			case MyDslPackage.LENGTH_ONE:
				sequence_RepeatedSERE(context, (LengthOne) semanticObject); 
				return; 
			case MyDslPackage.NEVER_BOOLEAN_PROPERTY:
				sequence_UnaryProperty(context, (NeverBooleanProperty) semanticObject); 
				return; 
			case MyDslPackage.NEVER_SEQUENCE_PROPERTY:
				sequence_UnaryProperty(context, (NeverSequenceProperty) semanticObject); 
				return; 
			case MyDslPackage.NEXT_EPROPERTY:
				sequence_UnaryProperty(context, (NextEProperty) semanticObject); 
				return; 
			case MyDslPackage.NEXT_EVENT_APROPERTY:
				sequence_BinaryProperty(context, (NextEventAProperty) semanticObject); 
				return; 
			case MyDslPackage.NOT_BOOLEAN_OR_OCL_LITERAL:
				sequence_BooleanOrOCLLiteral(context, (NotBooleanOrOCLLiteral) semanticObject); 
				return; 
			case MyDslPackage.OCL_LITERAL:
				sequence_BooleanOrOCLLiteral(context, (OCLLiteral) semanticObject); 
				return; 
			case MyDslPackage.OR_BOOLEAN_PROPERTY_PROPERTY:
				sequence_BinaryProperty(context, (OrBooleanPropertyProperty) semanticObject); 
				return; 
			case MyDslPackage.OR_PROPERTY_BOOLEAN_PROPERTY:
				sequence_Property(context, (OrPropertyBooleanProperty) semanticObject); 
				return; 
			case MyDslPackage.OVERLAPPING_SUFFIX_IMPLICATION_PROPERTY:
				sequence_BinaryProperty(context, (OverlappingSuffixImplicationProperty) semanticObject); 
				return; 
			case MyDslPackage.OVERLAPPING_UNTIL_PROPERTY:
				sequence_BinaryProperty(context, (OverlappingUntilProperty) semanticObject); 
				return; 
			case MyDslPackage.RANGE:
				sequence_Range(context, (Range) semanticObject); 
				return; 
			case MyDslPackage.SERE_AND_LM:
				sequence_BinaryCompoundSERE(context, (SEREAndLM) semanticObject); 
				return; 
			case MyDslPackage.SERE_AND_NLM:
				sequence_BinaryCompoundSERE(context, (SEREAndNLM) semanticObject); 
				return; 
			case MyDslPackage.SERE_OR:
				sequence_BinaryCompoundSERE(context, (SEREOr) semanticObject); 
				return; 
			case MyDslPackage.SERE_WITHIN:
				sequence_BinaryCompoundSERE(context, (SEREWithin) semanticObject); 
				return; 
			case MyDslPackage.SEQUENCE_CONSECUTIVE_REPETITION:
				sequence_RepeatedSERE(context, (SequenceConsecutiveRepetition) semanticObject); 
				return; 
			case MyDslPackage.SEQUENCE_COUNTED_CONSECUTIVE_REPETITION:
				sequence_RepeatedSERE(context, (SequenceCountedConsecutiveRepetition) semanticObject); 
				return; 
			case MyDslPackage.SEQUENCE_PROPERTY:
				sequence_UnaryProperty(context, (SequenceProperty) semanticObject); 
				return; 
			case MyDslPackage.SEQUENCE_TIGHT_PROPERTY:
				sequence_UnaryProperty(context, (SequenceTightProperty) semanticObject); 
				return; 
			case MyDslPackage.SUFFIX_IMPLICATION_PROPERTY:
				sequence_BinaryProperty(context, (SuffixImplicationProperty) semanticObject); 
				return; 
			case MyDslPackage.UNTIL_PROPERTY:
				sequence_Property(context, (UntilProperty) semanticObject); 
				return; 
			case MyDslPackage.WILD_CARD:
				sequence_RepeatedSERE(context, (WildCard) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Contexts:
	 *     SERE returns SEREAndLM
	 *     SimpleSERE returns SEREAndLM
	 *     CompoundSERE returns SEREAndLM
	 *     BinaryCompoundSERE returns SEREAndLM
	 *
	 * Constraint:
	 *     ((left=RepeatedSERE | left=BracedSERE | left=BinaryCompoundSERE) (right=RepeatedSERE | right=BracedSERE | right=BinaryCompoundSERE))
	 */
	protected void sequence_BinaryCompoundSERE(ISerializationContext context, SEREAndLM semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     SERE returns SEREAndNLM
	 *     SimpleSERE returns SEREAndNLM
	 *     CompoundSERE returns SEREAndNLM
	 *     BinaryCompoundSERE returns SEREAndNLM
	 *
	 * Constraint:
	 *     ((left=RepeatedSERE | left=BracedSERE | left=BinaryCompoundSERE) (right=RepeatedSERE | right=BracedSERE | right=BinaryCompoundSERE))
	 */
	protected void sequence_BinaryCompoundSERE(ISerializationContext context, SEREAndNLM semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     SERE returns SEREOr
	 *     SimpleSERE returns SEREOr
	 *     CompoundSERE returns SEREOr
	 *     BinaryCompoundSERE returns SEREOr
	 *
	 * Constraint:
	 *     ((left=RepeatedSERE | left=BracedSERE | left=BinaryCompoundSERE) (right=RepeatedSERE | right=BracedSERE | right=BinaryCompoundSERE))
	 */
	protected void sequence_BinaryCompoundSERE(ISerializationContext context, SEREOr semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     SERE returns SEREWithin
	 *     SimpleSERE returns SEREWithin
	 *     CompoundSERE returns SEREWithin
	 *     BinaryCompoundSERE returns SEREWithin
	 *
	 * Constraint:
	 *     ((left=RepeatedSERE | left=BracedSERE | left=BinaryCompoundSERE) (right=RepeatedSERE | right=BracedSERE | right=BinaryCompoundSERE))
	 */
	protected void sequence_BinaryCompoundSERE(ISerializationContext context, SEREWithin semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Property returns BeforeProperty
	 *     BinaryProperty returns BeforeProperty
	 *
	 * Constraint:
	 *     (left=BooleanOrOCLLiteral right=BooleanOrOCLLiteral)
	 */
	protected void sequence_BinaryProperty(ISerializationContext context, BeforeProperty semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.BINARY_PROPERTY__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.BINARY_PROPERTY__LEFT));
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.BINARY_PROPERTY__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.BINARY_PROPERTY__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getBinaryPropertyAccess().getLeftBooleanOrOCLLiteralParserRuleCall_4_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getBinaryPropertyAccess().getRightBooleanOrOCLLiteralParserRuleCall_4_3_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Property returns EquivalenceProperty
	 *     BinaryProperty returns EquivalenceProperty
	 *
	 * Constraint:
	 *     (left=BooleanOrOCLLiteral right=BooleanOrOCLLiteral)
	 */
	protected void sequence_BinaryProperty(ISerializationContext context, EquivalenceProperty semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.BINARY_PROPERTY__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.BINARY_PROPERTY__LEFT));
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.BINARY_PROPERTY__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.BINARY_PROPERTY__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getBinaryPropertyAccess().getLeftBooleanOrOCLLiteralParserRuleCall_2_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getBinaryPropertyAccess().getRightBooleanOrOCLLiteralParserRuleCall_2_3_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Property returns ImpliesProperty
	 *     BinaryProperty returns ImpliesProperty
	 *
	 * Constraint:
	 *     (left=BooleanOrOCLLiteral right=Property)
	 */
	protected void sequence_BinaryProperty(ISerializationContext context, ImpliesProperty semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.BINARY_PROPERTY__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.BINARY_PROPERTY__LEFT));
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.BINARY_PROPERTY__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.BINARY_PROPERTY__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getBinaryPropertyAccess().getLeftBooleanOrOCLLiteralParserRuleCall_1_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getBinaryPropertyAccess().getRightPropertyParserRuleCall_1_3_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Property returns NextEventAProperty
	 *     BinaryProperty returns NextEventAProperty
	 *
	 * Constraint:
	 *     (left=BooleanOrOCLLiteral range=Range right=Property)
	 */
	protected void sequence_BinaryProperty(ISerializationContext context, NextEventAProperty semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.BINARY_PROPERTY__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.BINARY_PROPERTY__LEFT));
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.NEXT_EVENT_APROPERTY__RANGE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.NEXT_EVENT_APROPERTY__RANGE));
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.BINARY_PROPERTY__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.BINARY_PROPERTY__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getBinaryPropertyAccess().getLeftBooleanOrOCLLiteralParserRuleCall_7_3_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getBinaryPropertyAccess().getRangeRangeParserRuleCall_7_6_0(), semanticObject.getRange());
		feeder.accept(grammarAccess.getBinaryPropertyAccess().getRightPropertyParserRuleCall_7_9_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Property returns OrBooleanPropertyProperty
	 *     BinaryProperty returns OrBooleanPropertyProperty
	 *
	 * Constraint:
	 *     (left=BooleanOrOCLLiteral right=Property)
	 */
	protected void sequence_BinaryProperty(ISerializationContext context, OrBooleanPropertyProperty semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.BINARY_PROPERTY__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.BINARY_PROPERTY__LEFT));
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.BINARY_PROPERTY__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.BINARY_PROPERTY__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getBinaryPropertyAccess().getLeftBooleanOrOCLLiteralParserRuleCall_0_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getBinaryPropertyAccess().getRightPropertyParserRuleCall_0_3_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Property returns OverlappingSuffixImplicationProperty
	 *     BinaryProperty returns OverlappingSuffixImplicationProperty
	 *
	 * Constraint:
	 *     (left=Sequence right=Property)
	 */
	protected void sequence_BinaryProperty(ISerializationContext context, OverlappingSuffixImplicationProperty semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.BINARY_PROPERTY__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.BINARY_PROPERTY__LEFT));
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.BINARY_PROPERTY__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.BINARY_PROPERTY__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getBinaryPropertyAccess().getLeftSequenceParserRuleCall_6_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getBinaryPropertyAccess().getRightPropertyParserRuleCall_6_3_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Property returns OverlappingUntilProperty
	 *     BinaryProperty returns OverlappingUntilProperty
	 *
	 * Constraint:
	 *     (left=BooleanOrOCLLiteral right=BooleanOrOCLLiteral)
	 */
	protected void sequence_BinaryProperty(ISerializationContext context, OverlappingUntilProperty semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.BINARY_PROPERTY__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.BINARY_PROPERTY__LEFT));
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.BINARY_PROPERTY__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.BINARY_PROPERTY__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getBinaryPropertyAccess().getLeftBooleanOrOCLLiteralParserRuleCall_3_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getBinaryPropertyAccess().getRightBooleanOrOCLLiteralParserRuleCall_3_3_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Property returns SuffixImplicationProperty
	 *     BinaryProperty returns SuffixImplicationProperty
	 *
	 * Constraint:
	 *     (left=Sequence right=Property)
	 */
	protected void sequence_BinaryProperty(ISerializationContext context, SuffixImplicationProperty semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.BINARY_PROPERTY__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.BINARY_PROPERTY__LEFT));
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.BINARY_PROPERTY__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.BINARY_PROPERTY__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getBinaryPropertyAccess().getLeftSequenceParserRuleCall_5_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getBinaryPropertyAccess().getRightPropertyParserRuleCall_5_3_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     BooleanOrOCLLiteral returns BooleanLiteral
	 *     SERE returns BooleanLiteral
	 *     SimpleSERE returns BooleanLiteral
	 *
	 * Constraint:
	 *     literal=BooleanLiteralExpCS
	 */
	protected void sequence_BooleanOrOCLLiteral(ISerializationContext context, BooleanLiteral semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.BOOLEAN_LITERAL__LITERAL) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.BOOLEAN_LITERAL__LITERAL));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getBooleanOrOCLLiteralAccess().getLiteralBooleanLiteralExpCSParserRuleCall_1_1_0(), semanticObject.getLiteral());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     BooleanOrOCLLiteral returns NotBooleanOrOCLLiteral
	 *     SERE returns NotBooleanOrOCLLiteral
	 *     SimpleSERE returns NotBooleanOrOCLLiteral
	 *
	 * Constraint:
	 *     literal=BooleanOrOCLLiteral
	 */
	protected void sequence_BooleanOrOCLLiteral(ISerializationContext context, NotBooleanOrOCLLiteral semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.NOT_BOOLEAN_OR_OCL_LITERAL__LITERAL) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.NOT_BOOLEAN_OR_OCL_LITERAL__LITERAL));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getBooleanOrOCLLiteralAccess().getLiteralBooleanOrOCLLiteralParserRuleCall_0_2_0(), semanticObject.getLiteral());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     BooleanOrOCLLiteral returns OCLLiteral
	 *     SERE returns OCLLiteral
	 *     SimpleSERE returns OCLLiteral
	 *
	 * Constraint:
	 *     literal=[ConstraintCS|ID]
	 */
	protected void sequence_BooleanOrOCLLiteral(ISerializationContext context, OCLLiteral semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.OCL_LITERAL__LITERAL) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.OCL_LITERAL__LITERAL));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getBooleanOrOCLLiteralAccess().getLiteralConstraintCSIDParserRuleCall_2_2_0_1(), semanticObject.getLiteral());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     SERE returns BracedSERE
	 *     SimpleSERE returns BracedSERE
	 *     Sequence returns BracedSERE
	 *     BracedSERE returns BracedSERE
	 *     CompoundSERE returns BracedSERE
	 *
	 * Constraint:
	 *     expression=SERE
	 */
	protected void sequence_BracedSERE(ISerializationContext context, BracedSERE semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.BRACED_SERE__EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.BRACED_SERE__EXPRESSION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getBracedSEREAccess().getExpressionSEREParserRuleCall_1_0(), semanticObject.getExpression());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Count returns Count
	 *
	 * Constraint:
	 *     COUNT=NUMBER
	 */
	protected void sequence_Count(ISerializationContext context, Count semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.COUNT__COUNT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.COUNT__COUNT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getCountAccess().getCOUNTNUMBERParserRuleCall_0_0(), semanticObject.getCOUNT());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Document returns Document
	 *
	 * Constraint:
	 *     (ownedImports+=Import* ownedProperties+=Property+)
	 */
	protected void sequence_Document(ISerializationContext context, Document semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Import returns Import
	 *
	 * Constraint:
	 *     importURI=IMPORT_URI
	 */
	protected void sequence_Import(ISerializationContext context, Import semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.IMPORT__IMPORT_URI) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.IMPORT__IMPORT_URI));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getImportAccess().getImportURIIMPORT_URITerminalRuleCall_1_0(), semanticObject.getImportURI());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Property returns AbortProperty
	 *
	 * Constraint:
	 *     ((left=UnaryProperty | left=BinaryProperty | left=UnaryProperty | left=BinaryProperty) right=BooleanOrOCLLiteral)
	 */
	protected void sequence_Property(ISerializationContext context, AbortProperty semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Property returns AndProperty
	 *
	 * Constraint:
	 *     ((left=UnaryProperty | left=BinaryProperty | left=UnaryProperty | left=BinaryProperty) right=Property)
	 */
	protected void sequence_Property(ISerializationContext context, AndProperty semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Property returns OrPropertyBooleanProperty
	 *
	 * Constraint:
	 *     ((left=UnaryProperty | left=BinaryProperty | left=UnaryProperty | left=BinaryProperty) right=Property)
	 */
	protected void sequence_Property(ISerializationContext context, OrPropertyBooleanProperty semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Property returns UntilProperty
	 *
	 * Constraint:
	 *     ((left=UnaryProperty | left=BinaryProperty | left=UnaryProperty | left=BinaryProperty) right=BooleanOrOCLLiteral)
	 */
	protected void sequence_Property(ISerializationContext context, UntilProperty semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Count returns Range
	 *     Range returns Range
	 *
	 * Constraint:
	 *     (LOWER_BOUND=NUMBER HIGHER_BOUND=NUMBER)
	 */
	protected void sequence_Range(ISerializationContext context, Range semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.RANGE__LOWER_BOUND) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.RANGE__LOWER_BOUND));
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.RANGE__HIGHER_BOUND) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.RANGE__HIGHER_BOUND));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getRangeAccess().getLOWER_BOUNDNUMBERParserRuleCall_0_0(), semanticObject.getLOWER_BOUND());
		feeder.accept(grammarAccess.getRangeAccess().getHIGHER_BOUNDNUMBERParserRuleCall_2_0(), semanticObject.getHIGHER_BOUND());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     SERE returns BooleanConsecutiveRepetition
	 *     SimpleSERE returns BooleanConsecutiveRepetition
	 *     Sequence returns BooleanConsecutiveRepetition
	 *     RepeatedSERE returns BooleanConsecutiveRepetition
	 *     CompoundSERE returns BooleanConsecutiveRepetition
	 *
	 * Constraint:
	 *     expression=BooleanOrOCLLiteral
	 */
	protected void sequence_RepeatedSERE(ISerializationContext context, BooleanConsecutiveRepetition semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.BOOLEAN_CONSECUTIVE_REPETITION__EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.BOOLEAN_CONSECUTIVE_REPETITION__EXPRESSION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getRepeatedSEREAccess().getExpressionBooleanOrOCLLiteralParserRuleCall_3_1_0(), semanticObject.getExpression());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     SERE returns BooleanCountedConsecutiveRepetition
	 *     SimpleSERE returns BooleanCountedConsecutiveRepetition
	 *     Sequence returns BooleanCountedConsecutiveRepetition
	 *     RepeatedSERE returns BooleanCountedConsecutiveRepetition
	 *     CompoundSERE returns BooleanCountedConsecutiveRepetition
	 *
	 * Constraint:
	 *     (expression=BooleanOrOCLLiteral count=Count?)
	 */
	protected void sequence_RepeatedSERE(ISerializationContext context, BooleanCountedConsecutiveRepetition semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     SERE returns BooleanCountedGotoRepetition
	 *     SimpleSERE returns BooleanCountedGotoRepetition
	 *     Sequence returns BooleanCountedGotoRepetition
	 *     RepeatedSERE returns BooleanCountedGotoRepetition
	 *     CompoundSERE returns BooleanCountedGotoRepetition
	 *
	 * Constraint:
	 *     (expression=BooleanOrOCLLiteral count=Count?)
	 */
	protected void sequence_RepeatedSERE(ISerializationContext context, BooleanCountedGotoRepetition semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     SERE returns BooleanCountedNonConsecutiveRepetition
	 *     SimpleSERE returns BooleanCountedNonConsecutiveRepetition
	 *     Sequence returns BooleanCountedNonConsecutiveRepetition
	 *     RepeatedSERE returns BooleanCountedNonConsecutiveRepetition
	 *     CompoundSERE returns BooleanCountedNonConsecutiveRepetition
	 *
	 * Constraint:
	 *     (expression=BooleanOrOCLLiteral count=Count)
	 */
	protected void sequence_RepeatedSERE(ISerializationContext context, BooleanCountedNonConsecutiveRepetition semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.BOOLEAN_COUNTED_NON_CONSECUTIVE_REPETITION__EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.BOOLEAN_COUNTED_NON_CONSECUTIVE_REPETITION__EXPRESSION));
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.BOOLEAN_COUNTED_NON_CONSECUTIVE_REPETITION__COUNT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.BOOLEAN_COUNTED_NON_CONSECUTIVE_REPETITION__COUNT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getRepeatedSEREAccess().getExpressionBooleanOrOCLLiteralParserRuleCall_6_1_0(), semanticObject.getExpression());
		feeder.accept(grammarAccess.getRepeatedSEREAccess().getCountCountParserRuleCall_6_4_0(), semanticObject.getCount());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     SERE returns LengthOne
	 *     SimpleSERE returns LengthOne
	 *     Sequence returns LengthOne
	 *     RepeatedSERE returns LengthOne
	 *     CompoundSERE returns LengthOne
	 *
	 * Constraint:
	 *     {LengthOne}
	 */
	protected void sequence_RepeatedSERE(ISerializationContext context, LengthOne semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     SERE returns SequenceConsecutiveRepetition
	 *     SimpleSERE returns SequenceConsecutiveRepetition
	 *     Sequence returns SequenceConsecutiveRepetition
	 *     RepeatedSERE returns SequenceConsecutiveRepetition
	 *     CompoundSERE returns SequenceConsecutiveRepetition
	 *
	 * Constraint:
	 *     (expression=BracedSERE | expression=RepeatedSERE)
	 */
	protected void sequence_RepeatedSERE(ISerializationContext context, SequenceConsecutiveRepetition semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     SERE returns SequenceCountedConsecutiveRepetition
	 *     SimpleSERE returns SequenceCountedConsecutiveRepetition
	 *     Sequence returns SequenceCountedConsecutiveRepetition
	 *     RepeatedSERE returns SequenceCountedConsecutiveRepetition
	 *     CompoundSERE returns SequenceCountedConsecutiveRepetition
	 *
	 * Constraint:
	 *     ((expression=BracedSERE count=Count?) | (expression=RepeatedSERE count=Count?))
	 */
	protected void sequence_RepeatedSERE(ISerializationContext context, SequenceCountedConsecutiveRepetition semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     SERE returns WildCard
	 *     SimpleSERE returns WildCard
	 *     Sequence returns WildCard
	 *     RepeatedSERE returns WildCard
	 *     CompoundSERE returns WildCard
	 *
	 * Constraint:
	 *     count=Count?
	 */
	protected void sequence_RepeatedSERE(ISerializationContext context, WildCard semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     SERE returns ConcatenationSERE
	 *
	 * Constraint:
	 *     (hd=SimpleSERE tl=SimpleSERE)
	 */
	protected void sequence_SERE(ISerializationContext context, ConcatenationSERE semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.CONCATENATION_SERE__HD) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.CONCATENATION_SERE__HD));
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.CONCATENATION_SERE__TL) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.CONCATENATION_SERE__TL));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getSEREAccess().getHdSimpleSEREParserRuleCall_2_1_0(), semanticObject.getHd());
		feeder.accept(grammarAccess.getSEREAccess().getTlSimpleSEREParserRuleCall_2_3_0(), semanticObject.getTl());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     SERE returns FusionSERE
	 *
	 * Constraint:
	 *     (hd=SimpleSERE tl=SimpleSERE)
	 */
	protected void sequence_SERE(ISerializationContext context, FusionSERE semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.FUSION_SERE__HD) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.FUSION_SERE__HD));
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.FUSION_SERE__TL) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.FUSION_SERE__TL));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getSEREAccess().getHdSimpleSEREParserRuleCall_1_1_0(), semanticObject.getHd());
		feeder.accept(grammarAccess.getSEREAccess().getTlSimpleSEREParserRuleCall_1_3_0(), semanticObject.getTl());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Property returns AlwaysProperty
	 *     UnaryProperty returns AlwaysProperty
	 *
	 * Constraint:
	 *     operand=Property
	 */
	protected void sequence_UnaryProperty(ISerializationContext context, AlwaysProperty semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.UNARY_PROPERTY__OPERAND) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.UNARY_PROPERTY__OPERAND));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getUnaryPropertyAccess().getOperandPropertyParserRuleCall_3_2_0(), semanticObject.getOperand());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Property returns BooleanProperty
	 *     UnaryProperty returns BooleanProperty
	 *
	 * Constraint:
	 *     operand=BooleanOrOCLLiteral
	 */
	protected void sequence_UnaryProperty(ISerializationContext context, BooleanProperty semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.UNARY_PROPERTY__OPERAND) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.UNARY_PROPERTY__OPERAND));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getUnaryPropertyAccess().getOperandBooleanOrOCLLiteralParserRuleCall_0_1_0(), semanticObject.getOperand());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Property returns EventuallyBooleanProperty
	 *     UnaryProperty returns EventuallyBooleanProperty
	 *
	 * Constraint:
	 *     operand=BooleanOrOCLLiteral
	 */
	protected void sequence_UnaryProperty(ISerializationContext context, EventuallyBooleanProperty semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.UNARY_PROPERTY__OPERAND) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.UNARY_PROPERTY__OPERAND));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getUnaryPropertyAccess().getOperandBooleanOrOCLLiteralParserRuleCall_7_2_0(), semanticObject.getOperand());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Property returns EventuallySequenceProperty
	 *     UnaryProperty returns EventuallySequenceProperty
	 *
	 * Constraint:
	 *     operand=Sequence
	 */
	protected void sequence_UnaryProperty(ISerializationContext context, EventuallySequenceProperty semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.UNARY_PROPERTY__OPERAND) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.UNARY_PROPERTY__OPERAND));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getUnaryPropertyAccess().getOperandSequenceParserRuleCall_8_2_0(), semanticObject.getOperand());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Property returns NeverBooleanProperty
	 *     UnaryProperty returns NeverBooleanProperty
	 *
	 * Constraint:
	 *     operand=BooleanOrOCLLiteral
	 */
	protected void sequence_UnaryProperty(ISerializationContext context, NeverBooleanProperty semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.UNARY_PROPERTY__OPERAND) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.UNARY_PROPERTY__OPERAND));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getUnaryPropertyAccess().getOperandBooleanOrOCLLiteralParserRuleCall_4_2_0(), semanticObject.getOperand());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Property returns NeverSequenceProperty
	 *     UnaryProperty returns NeverSequenceProperty
	 *
	 * Constraint:
	 *     operand=Sequence
	 */
	protected void sequence_UnaryProperty(ISerializationContext context, NeverSequenceProperty semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.UNARY_PROPERTY__OPERAND) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.UNARY_PROPERTY__OPERAND));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getUnaryPropertyAccess().getOperandSequenceParserRuleCall_5_2_0(), semanticObject.getOperand());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Property returns NextEProperty
	 *     UnaryProperty returns NextEProperty
	 *
	 * Constraint:
	 *     operand=BooleanOrOCLLiteral
	 */
	protected void sequence_UnaryProperty(ISerializationContext context, NextEProperty semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.UNARY_PROPERTY__OPERAND) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.UNARY_PROPERTY__OPERAND));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getUnaryPropertyAccess().getOperandBooleanOrOCLLiteralParserRuleCall_6_2_0(), semanticObject.getOperand());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Property returns SequenceProperty
	 *     UnaryProperty returns SequenceProperty
	 *
	 * Constraint:
	 *     operand=Sequence
	 */
	protected void sequence_UnaryProperty(ISerializationContext context, SequenceProperty semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.UNARY_PROPERTY__OPERAND) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.UNARY_PROPERTY__OPERAND));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getUnaryPropertyAccess().getOperandSequenceParserRuleCall_1_1_0(), semanticObject.getOperand());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Property returns SequenceTightProperty
	 *     UnaryProperty returns SequenceTightProperty
	 *
	 * Constraint:
	 *     operand=Sequence
	 */
	protected void sequence_UnaryProperty(ISerializationContext context, SequenceTightProperty semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.UNARY_PROPERTY__OPERAND) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.UNARY_PROPERTY__OPERAND));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getUnaryPropertyAccess().getOperandSequenceParserRuleCall_2_1_0(), semanticObject.getOperand());
		feeder.finish();
	}
	
	
}
